<!--
	作者：Sariay
	时间：2018-09-25
	描述：There may be a bug, but don't worry, QiLing(器灵) says that it can work normally!
-->


	<!DOCTYPE html>
	<html>
		

<head>
	<title>java面试-面试题合集（四）</title>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="apple-mobile-web-app-title" content="Amaze UI" />
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
    <meta name="author" content="John Doe">
    <meta name="keywords" content="" />
    <meta name="description" content="" />
   	<!-- css -->
	<link rel="stylesheet" href="/css/style.css">

	<!-- favicon -->
	<link href="/img/favicon.ico" rel="Shortcut Icon" type="image/ico">
	
	<!-- font-awesome -->
	<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
</head>
	<body>	
		<!--Preloader-->
<div id="preloader">
	<div id="status">
		<img alt="PRELOADER" src="/img/logo.png">
	</div>
</div>
<!--Preloader end-->

<!-- header -->

	<header id="header-bg-2">

	
		<div id="cd-logo"><a href="/"><img src="/img/logo.png" alt="Logo"></a></div>
	
	
	<!-- motto or description -->
		
 		<p class="motto"></p>
	
	
	<!-- current page name or title -->
	
		
		
			
			<p class=page-name>当前文章&nbsp;:&nbsp;《java面试-面试题合集（四）》</p>
			
		
	
	
	<!-- others: such as change-bg, time... -->
	<p class="page-name-other">
		10/10/2018 
		<style type="text/css">
	header:after {
		content: '';
		position: relative;
		top: 0;
		left: 0;
		height: 100%;
		width: 100%;
		background: #222222;
		opacity: .5;
		z-index: -1;
	}
	
	.change-header-bg{
		font-style: normal;
	}
	.change-header-bg i{
		text-align: center;
		cursor: pointer;
		pointer-events: bounding-box;
	}
	@media(max-width:512px) {
		.change-header-bg {
			display: none;
			visibility: hidden;
		}
	}
	
</style>

<script type="text/javascript">
	function changeHeaderBg(){
		var random_bg = Math.floor(Math.random() * 109 + 1);
		var bg = 'url(https://wuchaojob.gitee.io/random-img/' + random_bg + '.jpg)';
		$("#header-bg-2").css("background-image", bg);
	}
</script>

<span class="change-header-bg">
	——&nbsp;<i  class="fa fa-camera-retro" onclick="changeHeaderBg()"></i>	
</span>
	</p>		
</header>

<!-- nav -->
<div id="cd-nav">
	<a href="#0" title="menu" class="cd-nav-trigger"><span></span></a>

	<nav id="cd-main-nav">
		<ul>
			
      		<li class="fa fa-/">
           		<a href="/" title="主页">主页</a>	
      		</li>
    		
      		<li class="fa fa-/archives">
           		<a href="/archives" title="归档">归档</a>	
      		</li>
    		
      		<li class="fa fa-/categories">
           		<a href="/categories" title="分类">分类</a>	
      		</li>
    		
      		<li class="fa fa-/tags">
           		<a href="/tags" title="标签">标签</a>	
      		</li>
    		
      		<li class="fa fa-/about">
           		<a href="/about" title="关于">关于</a>	
      		</li>
    		
      		<li class="fa fa-/gallery">
           		<a href="/gallery" title="相册">相册</a>	
      		</li>
    		
    		
        	
		</ul>
	</nav>
</div>

		<!--main-->
		<main> 
		<div class="page-container">
		<!-- content srart -->
<div class="am-g am-g-fixed blog-fixed blog-content">
	<div class="am-u-md-8 am-u-sm-12">

		<article class="am-article blog-article-p">

			<div class="am-article-hd">
				


				<h1 class="am-article-title blog-text-center">
					
					
	
		<a href="/2018/10/10/java面试-面试题合集4/" itemprop="url">		
			java面试-面试题合集（四）		
		</a>
	

				</h1>

				<p class="am-article-meta blog-text-center">
					<span>
						<i class="fa fa-clock-o"></i> 
						<a href="/2018/10/10/java面试-面试题合集4/" itemprop="url">
	<time datetime="2018-10-10T05:02:17.521Z" itemprop="datePublished">
  		2018-10-10
  </time>
</a>    
&nbsp;
					</span>
					
					<span>						
						
							<i class="fa fa-tags"></i>
							
								<a href="#面试题" title="面试题" rel="4">面试题</a>&nbsp;
													 											
						
					</span>
				</p>
			</div>

			<div class="am-article-bd">
				<div class="content" id="post-content">
					
						<p><strong>String s = new String(“xyz”); 创建了几个字符串对象？</strong></p>
<p><strong>答</strong>：两个对象，一个是静态区的”xyz”，一个是用 new 创建在堆上的对象。</p>
<p><strong>接口是否可继承（ extends ）接口？抽象类是否可实现（ implements ）接<br>口？抽象类是否可继承具体类（ concrete class ）？</strong></p>
<p><strong>答</strong>：接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接<br>口，抽象类可继承具体类也可以继承抽象类。</p>
<p><strong>一个 “.java” 源文件中是否可以包含多个类（不是内部类）？有什么限<br>制？</strong></p>
<p><strong>答</strong>：可以，但一个源文件中最多只能有一个公开类（public class）而且文件<br>名必须和公开类的类名完全保持一致</p>
<p><strong>Anonymous Inner Class( 匿名内部类) ) 是否可以继承其它类？是否可以实<br>现接口？</strong></p>
<p><strong>答</strong>：可以继承其他类或实现其他接口，在 Swing 编程和 Android 开发中常用此<br>方式来实现事件监听和回调。</p>
<p><strong>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</strong></p>
<p><strong>答</strong>：一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<p><strong>Java中的final关键字有哪些用法？</strong></p>
<p><strong>答</strong>：(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；<br>(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。</p>
<p><strong>指出下面程序的运行结果。</strong></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/1A45795EF3644703AA5760486C670F16?method=download&amp;shareKey=849a49eb2669ac8e683f7f7c886ad5b7" alt="image"></p>
<p><strong>答</strong>：执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成<br>员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。</p>
<p><strong>数据类型之间的转换：</strong></p>
<ul>
<li><strong>如何将字符串转换为基本数据类型？</strong></li>
<li><strong>如何将基本数据类型转换为字符串？</strong></li>
</ul>
<p><strong>答</strong>：</p>
<ul>
<li>调用基本数据类型对应的包装类中的方法 parseXXX(String)或<br>valueOf(String)即可返回相应基本类型；</li>
<li>一种方法是将基本数据类型与空字符串（””）连接（+）即可获得其所对应的<br>字符串；另一种方法是调用 String 类中的 valueOf()方法返回相应字符串；</li>
</ul>
<p><strong>如何实现 字符串的反转及替换？</strong></p>
<p><strong>答</strong>：方法很多，可以自己写实现也可以使用 String 或<br>StringBuffer/StringBuilder 中的方法。有一道很常见的面试题是用递归实现<br>字符串反转，代码如下所示：</p>
<pre class="line-numbers language-bash"><code class="language-bash">public static String reverse<span class="token punctuation">(</span>String originStr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    if<span class="token punctuation">(</span>originStr <span class="token operator">==</span> null <span class="token operator">||</span> originStr.length<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> 1<span class="token punctuation">)</span>
    <span class="token keyword">return</span> originStr<span class="token punctuation">;</span>
    <span class="token keyword">return</span> reverse<span class="token punctuation">(</span>originStr.substring<span class="token punctuation">(</span>1<span class="token punctuation">))</span> +originStr.charAt<span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>怎样将 2 GB2312  编码的字符串转换为  ISO- - 8859- -1 1  编码的字符串？</strong></p>
<pre class="line-numbers language-bash"><code class="language-bash">String s1 <span class="token operator">=</span> <span class="token string">"你好"</span><span class="token punctuation">;</span>
String s2 <span class="token operator">=</span> new String<span class="token punctuation">(</span>s1.getBytes<span class="token punctuation">(</span><span class="token string">"GB2312"</span><span class="token punctuation">)</span>, <span class="token string">"ISO-8859-
1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>日期和时间：</strong></p>
<ul>
<li><strong>如何取得年月日、小时分钟秒？</strong></li>
<li><strong>如何取得从 0 1970 年 年 1 1 月 月 1 1 日 日 0 0 时 时 0 0 分 分 0 0  秒到现在的毫秒数？</strong></li>
<li><strong>如何取得 某月的最后一天？</strong></li>
<li><strong>如何格式化日期？</strong></li>
</ul>
<p><strong>答</strong>：<br>问题 1：创建 java.util.Calendar 实例，调用其 get()方法传入不同的参数即<br>可获得参数所对应的值。Java 8 中可以使用 java.time.LocalDateTimel 来获<br>取，代码如下所示。</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">import</span> java.time.LocalDateTime<span class="token punctuation">;</span>
<span class="token function">import</span> java.util.Calendar<span class="token punctuation">;</span>

public class DateTimeTest <span class="token punctuation">{</span>
    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Calendar <span class="token function">cal</span> <span class="token operator">=</span> Calendar.getInstance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>cal.get<span class="token punctuation">(</span>Calendar.YEAR<span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>cal.get<span class="token punctuation">(</span>Calendar.MONTH<span class="token punctuation">))</span><span class="token punctuation">;</span> //0 - 11
        System.out.println<span class="token punctuation">(</span>cal.get<span class="token punctuation">(</span>Calendar.DATE<span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>cal.get<span class="token punctuation">(</span>Calendar.HOUR_OF_DAY<span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>cal.get<span class="token punctuation">(</span>Calendar.MINUTE<span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>cal.get<span class="token punctuation">(</span>Calendar.SECOND<span class="token punctuation">))</span><span class="token punctuation">;</span>
        // Java 8
        LocalDateTime dt <span class="token operator">=</span> LocalDateTime.now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>dt.getYear<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>dt.getMonthValue<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span> // 1 -12
        System.out.println<span class="token punctuation">(</span>dt.getDayOfMonth<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>dt.getHour<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>dt.getMinute<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>dt.getSecond<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>打印昨天的当前时刻。</strong></p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">import</span> java.util.Calendar<span class="token punctuation">;</span>

class YesterdayCurrent <span class="token punctuation">{</span>
    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        Calendar <span class="token function">cal</span> <span class="token operator">=</span> Calendar.getInstance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cal.add<span class="token punctuation">(</span>Calendar.DATE, -1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>cal.getTime<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>在 Java 8 中，可以用下面的代码实现相同的功能。</strong></p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">import</span> java.time.LocalDateTime<span class="token punctuation">;</span>

class YesterdayCurrent <span class="token punctuation">{</span>
    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        LocalDateTime today <span class="token operator">=</span> LocalDateTime.now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        LocalDateTime yesterday <span class="token operator">=</span> today.minusDays<span class="token punctuation">(</span>1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System.out.println<span class="token punctuation">(</span>yesterday<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>比较一下 Java 和  JavaSciprt 。</strong></p>
<p><strong>答</strong>：JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun<br>Microsystems 公司推出的面向对象的程序设计语言，特别适合于互联网应用程<br>序开发；而 JavaScript 是 Netscape 公司的产品，为了扩展 Netscape 浏览器的<br>功能而开发的一种可以嵌入 Web 页面中运行的基于对象和事件驱动的解释性语<br>言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。<br>下面对两种语言间的异同作如下比较：</p>
<ul>
<li>基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单<br>的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与网络无<br>关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事<br>件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象<br>供设计人员使用。</li>
<li>解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种<br>解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览<br>器几乎都使用了 JIT（即时编译）技术来提升 JavaScript 的运行效率）</li>
<li>强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编译之<br>前必须作声明；JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声<br>明，JavaScript 的解释器在运行时检查推断其数据类型。</li>
<li>代码格式不一样。<br>补充：上面列出的四点是网上流传的所谓的标准答案。其实 Java 和<br>JavaScript 最重要的区别是一个是静态语言，一个是动态语言。目前的编程语<br>言的发展趋势是函数式语言和动态语言。在 Java 中类（class）是一等公民，<br>而 JavaScript 中函数（function）是一等公民，因此 JavaScript 支持函数式<br>编程，可以使用 Lambda 函数和闭包（closure），当然 Java 8 也开始支持函数<br>式编程，提供了对 Lambda 表达式以及函数式接口的支持。对于这类问题，在面<br>试的时候最好还是用自己的语言回答会更加靠谱，不要背网上所谓的标准答<br>案。</li>
</ul>
<p><strong>什么时候用断言（ assert ）？</strong></p>
<p>答：断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机<br>制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开<br>发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为<br>true；如果表达式的值为 false，那么系统会报告一个 AssertionError。断言<br>的使用如下面的代码所示：</p>
<pre class="line-numbers language-bash"><code class="language-bash">assert<span class="token punctuation">(</span>a <span class="token operator">></span> 0<span class="token punctuation">)</span><span class="token punctuation">;</span> // throws an AssertionError <span class="token keyword">if</span> a <span class="token operator">&lt;=</span> 0
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>断言可以有两种形式：</p>
<blockquote>
<p>assert Expression1;</p>
</blockquote>
<blockquote>
<p>assert Expression1 : Expression2 ;</p>
</blockquote>
<p>Expression1 应该总是产生一个布尔值。</p>
<p>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试<br>信息的字符串消息。</p>
<p>要在运行时启用断言，可以在启动 JVM 时使用-enableassertions 或者-ea 标<br>记。要在运行时选择禁用断言，可以在启动 JVM 时使用-da 或者-<br>disableassertions 标记。要在系统类中启用或禁用断言，可使用-esa 或-dsa<br>标记。还可以在包的基础上启用或者禁用断言。</p>
<p><strong>注意</strong>：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足<br>某些条件时阻止代码的执行，就可以考虑用断言来阻止它。</p>
<p><strong>Error和Exception有什么区别？</strong></p>
<p>答：Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很<br>困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的<br>情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或<br>实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。</p>
<p>面试题：2005 年摩托罗拉的面试中曾经问过这么一个问题“If a process<br>reports a stack overflow run-time error, what’s the most possible<br>cause?”，给了四个选项 a. lack of memory; b. write on an invalid<br>memory space; c. recursive function calling; d. array index out of<br>boundary. Java 程序在运行时也可能会遭遇 StackOverflowError，这是一个无<br>法恢复的错误，只能重新修改代码了，这个面试题的答案是 c。如果写了不能<br>迅速收敛的递归，则很有可能引发栈溢出的错误，如下所示：</p>
<pre class="line-numbers language-bash"><code class="language-bash">class StackOverflowErrorTest <span class="token punctuation">{</span>
    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        main<span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>提示</strong>：用递归编写程序时一定要牢记两点：1. 递归公式；2. 收敛条件（什么<br>时候就不再继续递归）。</p>
<p><strong>try{} 里有一个return语句，那么紧跟在这try后的finally{} 里的代<br>码会不会被执行，什么时候被执行，在return前还是后？</strong></p>
<p><strong>答</strong>：会执行，在方法返回调用者前执行</p>
<p><strong>注意</strong>：在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码<br>块，try 中的 return 语句不会立马返回调用者，而是记录下返回值待 finally<br>代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回<br>值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序<br>造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事<br>情，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误，<br>Eclipse 中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错<br>误。</p>
<p><strong>Java语言如何进行异常处理，关键字： throws 、 throw 、 try 、 catch 、<br>finally  分别如何使用</strong>？</p>
<p><strong>答</strong>：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并<br>提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或<br>其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有<br>异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。<br>Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws 和<br>finally。一般情况下是用 try 来执行一段程序，如果系统会抛出（throw）一<br>个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块<br>（finally）来处理；try 用来指定一块预防所有异常的程序；catch 子句紧跟<br>在 try 块后面，用来指定你想要捕获的异常的类型；throw 语句用来明确地抛<br>出一个异常；throws 用来声明一个方法可能抛出的各种异常（当然声明异常时<br>允许无病呻吟）；finally 为确保一段代码不管发生什么异常状况都要被执<br>行；try 语句可以嵌套，每当遇到一个 try 语句，异常的结构就会被放入异常<br>栈中，直到所有的 try 语句都完成。如果下一级的 try 语句没有对某种异常进<br>行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的 try 语句或者<br>最终将异常抛给 JVM。</p>
<p><strong>运行时异常与受检异常有何异同？</strong></p>
<p><strong>答</strong>：异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机<br>的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问<br>题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无<br>误，仍然可能因使用的问题而引发。Java 编译器要求方法必须声明抛出可能发<br>生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继<br>承一样，是面向对象程序设计中经常被滥用的东西，在 Effective Java 中对异<br>常的使用给出了以下指导原则：</p>
<ul>
<li>不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者<br>为了正常的控制流而使用异常）</li>
<li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li>
<li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发<br>生）</li>
<li>优先使用标准的异常</li>
<li>每个方法抛出的异常都要有文档</li>
<li>保持异常的原子性</li>
<li>不要在 catch 中忽略掉捕获到的异常</li>
</ul>
<p><strong>列出一些你常见的运行时异常？</strong></p>
<p><strong>答</strong>：</p>
<ul>
<li>ArithmeticException（算术异常）</li>
<li>ClassCastException （类转换异常）</li>
<li>IllegalArgumentException （非法参数异常）</li>
<li>IndexOutOfBoundsException （下标越界异常）</li>
<li>NullPointerException （空指针异常）</li>
<li>SecurityException （安全异常）</li>
</ul>
<p><strong>阐述  final 、 finally 、 finalize 的区别。</strong></p>
<p><strong>答</strong>：</p>
<ul>
<li>final：修饰符（关键字）有三种用法：如果一个类被声明为 final，意味着<br>它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。将变<br>量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必<br>须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为 final<br>的方法也同样只能使用，不能在子类中被重写。</li>
<li>finally：通常放在 try…catch…的后面构造总是执行代码块，这就意味着<br>程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以<br>将释放外部资源的代码写在 finally 块中。</li>
<li>finalize：Object 类中定义的方法，Java 中允许使用 finalize()方法在垃<br>圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾<br>收集器在销毁对象时调用的，通过重写 finalize()方法可以整理系统资源或者<br>执行其他清理工作。</li>
</ul>
<p><strong>类 ExampleA  继承  Exception ，类 ExampleB  继承  ExampleA 。</strong></p>
<p>有如下代码片断：</p>
<pre class="line-numbers language-bash"><code class="language-bash">try <span class="token punctuation">{</span>
    throw new ExampleB<span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> catch（ExampleA e）<span class="token punctuation">{</span>
    System.out.println<span class="token punctuation">(</span><span class="token string">"ExampleA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> catch（Exception e）<span class="token punctuation">{</span>
    System.out.println<span class="token punctuation">(</span><span class="token string">"Exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>请问执行此段代码的输出是什么？</strong></p>
<p><strong>答</strong>：输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子<br>类型]，抓取 ExampleA 类型异常的 catch 块能够抓住 try 块中抛出的 ExampleB<br>类型的异常）</p>
<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java 编程思想》一<br>书）<br><img src="https://note.youdao.com/yws/api/personal/file/F8B946F9629A4F7E8E5AE5C39B2FE632?method=download&amp;shareKey=64794f83fd828a224d9e6866caf533c8" alt="image"></p>
<p><strong>List 、 Set 、 Map  是否继承自Collection接口？</strong></p>
<p><strong>答</strong>：List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显<br>的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如<br>此），List 是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<p><strong>阐述 ArrayList 、 Vector 、LinkedList  的存储性能和特性。</strong></p>
<p>答：ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际<br>存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入<br>元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但<br>性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双<br>向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一<br>个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相<br>比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插<br>入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector 属于遗留<br>容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、<br>BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于<br>ArrayList 和 LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个<br>容器的场景，则可以通过工具类 Collections 中的 synchronizedList 方法将其<br>转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另<br>一个类的构造器中创建新的对象来增强实现）。</p>
<p><strong>补充</strong>：遗留容器中的 Properties 类和 Stack 类在设计上有严重的问题，<br>Properties 是一个键和值都是字符串的特殊的键值对映射，在设计上应该是关<br>联一个 Hashtable 并将其两个泛型参数设置为 String 类型，但是 Java API 中<br>的 Properties 直接继承了 Hashtable，这很明显是对继承的滥用。这里复用代<br>码的方式应该是 Has-A 关系而不是 Is-A 关系，另一方面容器都属于工具类，继<br>承工具类本身就是一个错误的做法，使用工具类最好的方式是 Has-A 关系（关<br>联）或 Use-A 关系（依赖）。同理，Stack 类继承 Vector 也是不正确的。Sun<br>公司的工程师们也会犯这种低级错误，让人唏嘘不已。</p>
<p>Collection和Collections的区别？</p>
<p><strong>答</strong>：Collection 是一个接口，它是 Set、List 等容器的父接口；Collections<br>是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对<br>容器的搜索、排序、线程安全化等等。</p>
<p><strong>List 、 Map 、Set  三个 接口存取元素时，各有什么特点？</strong></p>
<p><strong>答</strong>：List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素<br>（用对象的 equals()方法来区分元素是否重复）。Map 保存键值对（key-value<br>pair）映射，映射关系可以是一对一或多对一。Set 和 Map 容器都有基于哈希<br>存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为<br>O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键<br>（key）构成排序树从而达到排序和去重的效果。</p>
<p><strong>TreeMap 和 TreeSet在排序时如何比较元素？ Collections  工具类中的<br>sort()如何比较元素</strong></p>
<p><strong>答</strong>：TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供<br>了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大<br>小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键<br>对元素进行排序。Collections 工具类的 sort 方法有两种重载的形式，第一种<br>要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比<br>较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参<br>数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比<br>较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）</p>
<p><strong>Thread  类的  sleep() 方法和对象的  wait() 方法都可以让线程暂停执行，它<br>们有什么区别? </strong></p>
<p>答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当<br>前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁<br>依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第 66<br>题中的线程状态转换图）。wait()是 Object 类的方法，调用对象的 wait()方<br>法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait<br>pool），只有调用对象的 notify()方法（或 notifyAll()方法）时才能唤醒等<br>待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进<br>入就绪状态。</p>
<p><strong>补充</strong>：可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多<br>线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某<br>个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单<br>位；线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的<br>能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发<br>性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使<br>用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于<br>其他程序是不友好的，因为它可能占用了更多的 CPU 资源。当然，也不是线程<br>越多，程序的性能就越好，因为线程之间的调度和切换也会浪费 CPU 时间。时<br>下很时髦的 Node.js 就采用了单线程异步 I/O 的工作模式</p>
<p><strong>线程的  sleep() 方法和  yield() 方法有什么区别？</strong></p>
<p><strong>答</strong>：</p>
<ul>
<li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先<br>级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以<br>运行的机会；</li>
<li>线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后<br>转入就绪（ready）状态；</li>
<li>sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任<br>何异常；</li>
<li>sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移<br>植性。</li>
</ul>
<p><strong>当一个线程进入一个对象的 synchronized  方法 A  之后，其它线程是否可<br>进入此对象的 synchronized  方法  B ？</strong></p>
<p><strong>答</strong>：不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因<br>为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果<br>已经进入 A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在<br>等锁池（ 注意不是等待池哦）中等待对象的锁。</p>
<p><strong>请说出与线程同步以及线程调度相关的方法。</strong></p>
<ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方<br>法要处理 InterruptedException 异常；</li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不<br>能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与<br>优先级无关；</li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所<br>有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li>
</ul>
<p><strong>补充</strong>：Java 5 通过 Lock 接口提供了显式的锁机制（explicit lock），增强了<br>灵活性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁<br>（unlock()）的方法，同时还提供了 newCondition()方法来产生用于线程之间<br>通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），<br>信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访<br>问之前，线程必须得到信号量的许可（调用 Semaphore 对象的 acquire()方<br>法）；在完成对资源的访问后，线程必须向信号量归还许可（调用 Semaphore<br>对象的 release()方法）。</p>

					
				</div>
			</div>
		</article>

		<ul class="am-pagination">
    
	
		<li class="am-pagination-next">
		<a class="pull-right" href="/2018/10/09/java面试-面试题合集3/" title="java面试-面试题合集（三）">
			下一篇 &raquo;
		</a>
		</li>
	 
 </ul>
        

		<div class="theme-annie-comment-button-container">
	<button id="annie-comment-button" class="theme-annie-comment-button" onclick="Annie_Comment()">
		加载评论
		<!--加载评论-->
	</button>
</div>

<div id="annie-comment-container" class="theme-annie-comment-main-container">

	
		
			<!-- comment valine -->
			<!-- show valine comment -->
<div id="valineComment" class="comment"></div>

<!-- valine`s js & css -->
<script>
	window.jQuery || document.write('<script src="/js/jquery-2.1.1.min.js"><\/script>')
</script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/js/valine.min.js"></script>
<link rel="stylesheet" href="/css/comment.css">

<script>
	var checkExistComment = setInterval(function() {
		if( $('#valineComment').length ) {
			new Valine({
				// AV 对象来自上面引入av-min.js(老司机们不要开车➳♡゛扎心了老铁)
				av: AV,
				//使用id寻找div元素（使用class可能找不到）
				el: '#valineComment',
				emoticon_url: 'https://cloud.panjunwen.com/alu',
				emoticon_list: ["吐.png", "期待.png", "高兴.png", "吐血倒地.png", "哭泣.png", "欢呼.png"],
				app_id: "3333....", //获取APP ID
				app_key: "3333......", //获取APP KEY
				placeholder: "no any!", //评论框占位提示文字        			
			});
			clearInterval(checkExistComment);
		}
	}, 100);
</script>
		
	

</div>

<script type="text/javascript">
	/* Show Comment */
	var Annie_Comment = function() {
		function Show_Hidden(obj) {
			obj.style.display = 'block';
		}
		
		//var obutton = $('#annie-comment-button');
		//var obutton = $('#annie-comment-container');
		var obutton = document.getElementById("annie-comment-button" || "0");
		var odiv = document.getElementById("annie-comment-container");
		if( 'obutton' ) {
			obutton.onclick = function() {
				Show_Hidden(odiv);
				$("#annie-comment-button").css("display", 'none');
				return false;
			}
		}
	};

	(function Annie_Init() {
		Annie_Comment();
	})();
</script>
		
		<!--
	时间：2018-09-24
	描述：The TOC module refers to 'https://github.com/codefine/hexo-theme-mellow', include toc.ejs、toc.js、toc.css. All rights reserved by codefine. 
-->

	

	</div>
</div>
		</div>
		</main>
		
		<!--footer-->
		<footer>
	<div class="blog-text-center">
		<div class="theme-annie-social">
				
				
					<a href="https://github.com/520Muzili" title="Github" target="_blank"><i class="fa fa-github"></i>&nbsp;</a>
					
				
					<a href="https://github.com/520Muzili" title="Weibo" target="_blank"><i class="fa fa-weibo"></i>&nbsp;</a>
				
				
					<a href="https://github.com/520Muzili" title="Email" target="_blank"><i class="fa fa-envelope-o"></i>&nbsp;</a>
					
				
					<a href="https://github.com/520Muzili" title="QQ" target="_blank"><i class="fa fa-qq"></i>&nbsp;</a>
					
				
					<a href="https://github.com/520Muzili" title="Twitter" target="_blank"><i class="fa fa-twitter"></i>&nbsp;</a>
						
				
		</div>
	</div>

	<div  class="blog-text-center">
		<div class="theme-annie-copyright">
			
				&copy; 2017 - 2018, content by 木子李. All Rights Reserved.			       	
			
		</div>
	</div>

	
</footer>
		<!-- <script src="http://code.jquery.com/jquery-2.1.1.min.js" type="text/javascript"></script> -->

<script>
	window.jQuery || document.write('<script src="/js/jquery-2.1.1.min.js"><\/script>')
</script>

<style>
	.motto {
		color: #000000;
		font-size: 20px;
		margin: 100px 25% 0;
		width: 50%;
		line-height: 1.4;
		font-family:"KaiTi", "STXingkai", "Source Sans Pro", "Segoe UI", "Lucida Grande", Helvetica, Arial, "Microsoft YaHei", FreeSans, Arimo, "Droid Sans", "wenquanyi micro hei", "Hiragino Sans GB", "Hiragino Sans GB W3", FontAwesome, sans-serif;
		text-align: center;
	}
	@media(max-width: 890px) {
		.motto {	
			margin: 100px 10% 0;
			width: 80%;
		}
	}
	@media(max-width: 890px) {
		.motto {
			margin: 100px 5% 0;
			width: 90%;
		}
	}
</style>


	<script src="/js/motto.js"></script>
	<script type="text/javascript">
		$(".motto").html(getMingYanContent());
	</script>	







	<script type="text/javascript" src="/js/toc.js"></script>


<script type="text/javascript" src="/js/main.js"></script>

<script type="text/javascript">
	//generate a random img that pre_name 'from 0 to 110'
	var random_bg = Math.floor(Math.random() * 109 + 1);

	//var bg = 'url(/img/random/' + random_bg + '.jpg)';		
	var bg = 'url(https://wuchaojob.gitee.io/random-img/' + random_bg + '.jpg)';

	$("#header-bg-2").css("background-image", bg);
</script>
		
		<!--back to top-->
        <style type="text/css">
	#totop {
		background: white;
		border-radius: 50%;
		position: fixed;
		right: 5.4%;
		bottom: 80px;
		cursor: pointer;
	}
	
	#totop a {
		color: #474747;
		background-color: transparent;
		padding: 10px;
		text-decoration: none;
	}
	
	@media(max-width:512px) {
		#totop {
			display: none;
			visibility: hidden;
		}
	}
</style>


	<div id="totop">
  		<a href="javascript:;" class="fa fa-arrow-up"></a>
	</div>

	</body>
	</html>

